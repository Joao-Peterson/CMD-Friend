# CMD_Friend - The Command line friend library!

Simple command line arguments parser for C and C++ applications.

This library is made for C and C++ programs to parse command line options in the easiest way possible.
Based heavily on the argp library of the GNU project.

TL;DR: Sources and include files are in [modules/cmd_friend](./modules/cmd_friend). Compile static .a and dynamic .dll libraries are in [modules/cmd_friend/lib](./modules/cmd_friend/lib). Make a cmdf_options array for your options, make a parse function, call the main cdmf_parse_options() function.

Created by: Jo√£o Peterson Scheffer - 2020.
Version: v1.2

Documentation generated by Doxygen, saved in [docs](./docs) folder and hosted on [Github pages](https://joao-peterson.github.io/CMD-Friend/), click to redirect.

### Compilation

To compile this library simply compile the source with the header, no dependencies.
Arquive if static compile or compile as shared and you can use in your projects, or as i like, compile the source into a object
and link it with your main application in compilation or linking step.

### Use

To use, first you can define strings with default program information in you main function:
```c
    set_cmdf_default_info_usage("Usage: [-w,-o,-f] for project or [-M,-m] for module [FILEPATH] [OPTIONS...]");
    set_cmdf_default_info_version("v1.1 - 17/08/2020");
    set_cmdf_default_info_contact_info("Repo: https://github.com/Joao-Peterson/CMD-Friend - Email: joco_zx@hotmail.com");
```
Then make a array of options in your main aplication outside main(). Eg:

```c
    cmdf_options options[] = 
    {
        {"where",   'w', 0,                                             1, "Where to create the project"},
        {"file",    'f', OPTION_ALIAS },
        {"tags",    't', OPTION_OPTIONAL,                              -1, "Tags to put in"},
        {"verbose", 'v', OPTION_OPTIONAL | OPTION_NO_LONG_KEY,          0, "Verbose mode"},
        {"Wall",    'W', OPTION_OPTIONAL,                               0, "Wall error mode"},
        {"vscode",   VSCODE_KEY, OPTION_OPTIONAL | OPTION_NO_CHAR_KEY,  0, "Visual studio code .vscode folder with .json configuration files"},
        {0}
    };
```

Define a struct of your flavor that hold flags and variables associated with your options, these will be used later in your main aplication. Eg:

```c
    struct arguments_info
    {
        char *filepath_project;         /**< filepath to generte template project*/
        int tags;                       /**< int that has bitwise tags*/
        int verbose_enable;             /**< flag that indicates if the program will print to console*/
        int wall_enable;                /**< flag that indicates if the program will use wall commands*/
        int generate_vscode_folder;     /**< flag that indicates to generate a vscode folder with .json configuration files*/
    };
```

Then define a parser function for your options. It should contain a cast to your custom struct and
a switch case with cases for your options. Eg:

```c 
    int parse_options(char key, char *arg, int arg_pos, void *extern_user_variables_struct)
    {
        struct arguments_info *myvariables = (struct arguments_info*)extern_user_variables_struct; // retrieving custom struct by casting
        long int tag_bit;

        switch (key)
        {
            case 'w': case 'f':                             // --where, --output, --folder 
                myvariables->filepath_project = arg;
                printf("[ARG] Argument \"%s\" for key -%c .\n",arg,key);
                break;

            case 't':                                       // --tags
                if((tag_bit = strtol(arg, NULL, 10)) > INT_MAX)
                {
                    printf("[ARG] Argument \"%s\" for key -%c needs to be smaller than %ld.\n",arg,key,INT_MAX);
                    exit(1);
                }
                else
                    myvariables->tags |= tag_bit;                
                
                printf("[ARG] Number \"%X\" for key -%c .\n",tag_bit,key);
                
                break;

            case 'v':                                       // --verbose
                printf("[ARG] verbose\n");
                myvariables->verbose_enable = 1;
                break;
            
            case 'W':                                       // --Wall
                myvariables->wall_enable = 1;
                printf("[ARG] Wall\n");
                break;

            case VSCODE_KEY:                                // --vscode
                myvariables->generate_vscode_folder = 1;
                printf("[ARG] VSCODE!\n");
                break;

            case 0:                                         
                printf("[ARG] Case 0 hapenned! Key: -%c Arg: %s\n",key,arg);
                break;                          

            default: 
                printf("[ARG] Case default hapenned! Key: -%c Arg: %s\n",key,arg);
                break;
        }

        return 0;
    }
``` 

Finally you can call the main library function and then use your processed flags and variables in your custom struct
as you desire. Eg:

```c
    cdmf_parse_options(options, parse_options, argc, argv, PARSER_FLAG_PRINT_ERRORS_STDOUT | PARSER_FLAG_USE_PREDEFINED_OPTIONS | PARSER_FLAG_DONT_IGNORE_NON_REGISTERED_OPTIONS, &myvars);
```
