# CMD_Friend - The Command line friend library!

Simple command line arguments parser for C and C++ applications.

This library is made for C and C++ programs to parse command line options in the easiest way possible.
Based heavily on the argp library of the GNU project.

TL;DR: Sources and include files are in [modules/cmd_friend](./modules/cmd_friend). Compile static .a and dynamic .dll libraries are in [modules/cmd_friend/lib](./modules/cmd_friend/lib).

Created by: JoÃ£o Peterson Scheffer - 2020.
Version: v1.1

Documentation generated by Doxygen, saved in [docs](./docs) folder and hosted on [Github pages](https://joao-peterson.github.io/CMD-Friend/), click to redirect.

### Compilation

To compile this library simply compile the source with the header, no dependencies.
Arquive if static compile or compile as shared and you can use in your projects, or as i like, compile the source into a object
and link it with your main application in compilation or linking step.

### Use

To use, first you can define strings with default program information in you main function:
```c
    set_cmdf_default_info_usage("Usage: [-w,-o,-f] for project or [-M,-m] for module [FILEPATH] [OPTIONS...]");
    set_cmdf_default_info_version("v1.1 - 17/08/2020");
    set_cmdf_default_info_contact_info("Repo: https://github.com/Joao-Peterson/CMD-Friend - Email: joco_zx@hotmail.com");
```
Then make a array of options in your main aplication outside main(). Eg:

```c
    cmdf_options options[] = 
    {
        {"where",   'w', OPTION_OPTIONAL, 1, "Where to create the project"},
        {"output",  'o', OPTION_ALIAS},
        {"folder",  'f', OPTION_ALIAS},
        {"module",  'M', OPTION_OPTIONAL, 1, "To generate a module template in the folder specified"},
        {"mod",     'm', OPTION_ALIAS},
        {"verbose", 'v', OPTION_OPTIONAL, 0, "Verbose mode"},
        {"verbose+",'V', OPTION_OPTIONAL, 0, "Verbose plusmode"},
        {"Wall",    'W', OPTION_OPTIONAL, 0, "Wall error mode"},
        {"vscode",   VSCODE_KEY, OPTION_OPTIONAL | OPTION_NO_CHAR_KEY, 0, "Visual studio code .vscode folder with .json configuration files"},
        {0}
    };
```

Define a struct of your flavor that hold flags and variables associated with your options, these will be used later in your main aplication. Eg:

```c
    struct arguments_info
    {
        char *filepath_project;       
        char *filepath_module;        
        int generate_vscode_folder;
        int verbose_enable;           
    };
```

Then define a parser function for your options. It should contain a cast to your custom struct and
a switch case with cases for your options. Eg:

```c 
    int parse_options(char key, char *arg, int arg_pos, void *extern_user_variables_struct)
    {
        struct arguments_info *myvariables = (struct arguments_info*)extern_user_variables_struct; // retrieving custom struct
    
        switch (key)
        {
            case 'w': case 'o': case 'f':                   // --where, --output, --folder 
                myvariables->filepath_project = arg;
                break;
    
            case 'M': case 'm':                             // --module, -- mod
                myvariables->filepath_module = arg;
                break;
    
            case 'v':                                       // --verbose
                printf("verbose\n");
                myvariables->verbose_enable = 1;
                break;
            
            case 'V':                                       // --Verbose+
                printf("Verbose+\n");
                break;
            
            case 'W':                                       // --Wall
                printf("Wall\n");
                break;
    
            case VSCODE_KEY:                                // --vscode
                myvariables->generate_vscode_folder = 1;
                break;
    
            case 0:                                         // case 0, if a list of arguments is given before any option, or zero argumetns passed
                printf("Case 0 hapenned!\n");
                break;                          
    
            default:                                        // uhandled cases of registered options
                printf("Case default hapenned!\n");
                break;
        }
    
        return 0;
    }
``` 

Finally you can call the main library function and then use your processed flags and variables in your custom struct
as you desire. Eg:

```c
    cdmf_parse_options(options, parse_options, argc, argv, PARSER_FLAG_PRINT_ERRORS_STDOUT | PARSER_FLAG_USE_PREDEFINED_OPTIONS, &myvars);
```
